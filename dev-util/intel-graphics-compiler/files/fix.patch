From ac1aea788fb7369358dfdce57635333fe7ebf940 Mon Sep 17 00:00:00 2001
From: Pawel Szymichowski <pawel.szymichowski@intel.com>
Date: Mon, 18 Jan 2021 11:39:55 +0000
Subject: [PATCH] Changes in code.

---
 IGC/Compiler/CISACodeGen/ResolveGAS.cpp       |  2 +
 .../PrivateMemory/PrivateMemoryToSLM.cpp      |  3 +-
 .../OpenCLPasses/WIFuncs/WIFuncResolution.cpp | 25 ++++-----
 .../lib/GenXCodeGen/GenXLegalization.cpp      |  2 +-
 .../lib/GenXCodeGen/GenXPatternMatch.cpp      | 10 ++--
 .../GenXCodeGen/GenXThreadPrivateMemory.cpp   |  4 +-
 IGC/WrapperLLVM/CMakeLists.txt                |  1 +
 .../include/llvmWrapper/IR/DataLayout.h       | 54 +++++++++++++++++++
 .../include/llvmWrapper/Support/Alignment.h   |  2 +-
 9 files changed, 80 insertions(+), 23 deletions(-)
 create mode 100644 IGC/WrapperLLVM/include/llvmWrapper/IR/DataLayout.h

diff --git a/IGC/Compiler/CISACodeGen/ResolveGAS.cpp b/IGC/Compiler/CISACodeGen/ResolveGAS.cpp
index 090d4fbec..70ef58f30 100644
--- a/IGC/Compiler/CISACodeGen/ResolveGAS.cpp
+++ b/IGC/Compiler/CISACodeGen/ResolveGAS.cpp
@@ -38,6 +38,8 @@ SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include <llvm/ADT/SmallVector.h>
 #include <llvm/ADT/PostOrderIterator.h>
 #include <llvm/Analysis/LoopInfo.h>
+#include <llvm/Analysis/AliasAnalysis.h>
+#include <llvm/Analysis/MemoryLocation.h>
 #include <llvm/IR/IRBuilder.h>
 #include <llvm/IR/NoFolder.h>
 #include <llvm/Pass.h>
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/PrivateMemory/PrivateMemoryToSLM.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/PrivateMemory/PrivateMemoryToSLM.cpp
index fd1e76562..838558890 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/PrivateMemory/PrivateMemoryToSLM.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/PrivateMemory/PrivateMemoryToSLM.cpp
@@ -7,6 +7,7 @@
 #include "Compiler/Optimizer/OpenCLPasses/PrivateMemory/PrivateMemoryResolution.hpp"
 
 #include "common/debug/Debug.hpp"
+#include "llvmWrapper/IR/DataLayout.h"
 #include "llvmWrapper/Support/Alignment.h"
 
 #include <fstream>
@@ -191,7 +192,7 @@ namespace IGC
             {
                 PointerType* ptrType = dyn_cast<PointerType>(offsets.m_Var->getType());
                 Type* varType = ptrType->getElementType();
-                offset = iSTD::Align(offset, DL.getPreferredAlignment(offsets.m_Var));
+                offset = iSTD::Align(offset, IGCLLVM::getPreferredAlignValue(&DL, offsets.m_Var));
                 offset += (unsigned int) DL.getTypeAllocSize(varType);
             }
 
diff --git a/IGC/Compiler/Optimizer/OpenCLPasses/WIFuncs/WIFuncResolution.cpp b/IGC/Compiler/Optimizer/OpenCLPasses/WIFuncs/WIFuncResolution.cpp
index 0ed598983..e90723d8c 100644
--- a/IGC/Compiler/Optimizer/OpenCLPasses/WIFuncs/WIFuncResolution.cpp
+++ b/IGC/Compiler/Optimizer/OpenCLPasses/WIFuncs/WIFuncResolution.cpp
@@ -33,6 +33,7 @@ SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 #include "common/LLVMWarningsPop.hpp"
 #include "Probe/Assertion.h"
 #include <llvmWrapper/Support/Alignment.h>
+#include <llvmWrapper/IR/DerivedTypes.h>
 
 using namespace llvm;
 using namespace IGC;
@@ -282,7 +283,7 @@ static Value* BuildLoadInst(CallInst& CI, unsigned int Offset, unsigned int Size
     auto F = CI.getFunction();
     auto Int32Ptr = PointerType::get(Type::getInt32Ty(F->getParent()->getContext()), ADDRESS_SPACE_A32);
     auto ElemType = Type::getInt8Ty(F->getParent()->getContext());
-    auto LoadType = VectorType::get(ElemType, LoadSize);
+    auto LoadType = IGCLLVM::FixedVectorType::get(ElemType, LoadSize);
     auto PtrType = PointerType::get(LoadType, ADDRESS_SPACE_A32);
     auto IntToPtr = Builder.CreateIntToPtr(Builder.getIntN(F->getParent()->getDataLayout().getPointerSizeInBits(ADDRESS_SPACE_A32), AlignedOffset), Int32Ptr);
     auto BitCast = Builder.CreateBitCast(IntToPtr, PtrType);
@@ -291,7 +292,7 @@ static Value* BuildLoadInst(CallInst& CI, unsigned int Offset, unsigned int Size
 
     if (Offset != AlignedOffset)
     {
-        Value* NewVector = UndefValue::get(VectorType::get(ElemType, Size));
+        Value* NewVector = UndefValue::get(IGCLLVM::FixedVectorType::get(ElemType, Size));
         for (unsigned int I = Offset; I != (Offset + Size); ++I)
         {
             auto Elem = Builder.CreateExtractElement(LoadInst, I - AlignedOffset);
@@ -349,7 +350,7 @@ Value* WIFuncResolution::getGroupId(CallInst& CI)
         auto Ctx = getAnalysis<CodeGenContextWrapper>().getCodeGenContext();
         llvm::IRBuilder<> Builder(&CI);
         Type* Int32Ty = Type::getInt32Ty(F->getParent()->getContext());
-        VectorType* Tys = VectorType::get(Int32Ty, Ctx->platform.getGRFSize() / SIZE_DWORD);
+        VectorType* Tys = IGCLLVM::FixedVectorType::get(Int32Ty, Ctx->platform.getGRFSize() / SIZE_DWORD);
         Function* R0Dcl = GenISAIntrinsic::getDeclaration(F->getParent(), GenISAIntrinsic::ID::GenISA_getR0, Tys);
         auto IntCall = Builder.CreateCall(R0Dcl);
         V = IntCall;
@@ -387,12 +388,12 @@ Value* WIFuncResolution::getGlobalSize(CallInst& CI)
     {
         llvm::IRBuilder<> Builder(&CI);
         auto ElemTypeQ = Type::getInt64Ty(F->getParent()->getContext());
-        auto VecTyQ = VectorType::get(ElemTypeQ, 3);
+        auto VecTyQ = IGCLLVM::FixedVectorType::get(ElemTypeQ, 3);
         unsigned int Offset = GLOBAL_STATE_FIELD_OFFSETS::GLOBAL_SIZE_X;
         unsigned int Size = sizeof(uint64_t) * 3;
         auto LoadInst = BuildLoadInst(CI, Offset, Size, VecTyQ);
         auto ElemType = CI.getType();
-        Value* Undef = UndefValue::get(VectorType::get(ElemType, 3));
+        Value* Undef = UndefValue::get(IGCLLVM::FixedVectorType::get(ElemType, 3));
         for (unsigned int I = 0; I != 3; ++I)
         {
             // Extract each dimension, truncate to i32, then insert in new vector
@@ -429,7 +430,7 @@ Value* WIFuncResolution::getLocalSize(CallInst& CI)
     {
         llvm::IRBuilder<> Builder(&CI);
         auto ElemTypeD = Type::getInt32Ty(F->getParent()->getContext());
-        auto VecTyD = VectorType::get(ElemTypeD, 3);
+        auto VecTyD = IGCLLVM::FixedVectorType::get(ElemTypeD, 3);
         unsigned int Offset = GLOBAL_STATE_FIELD_OFFSETS::LOCAL_SIZE_X;
         unsigned int Size = sizeof(uint32_t) * 3;
         auto LoadInst = BuildLoadInst(CI, Offset, Size, VecTyD);
@@ -462,7 +463,7 @@ Value* WIFuncResolution::getEnqueuedLocalSize(CallInst& CI) {
         // Assume that enqueued local size is same as local size
         llvm::IRBuilder<> Builder(&CI);
         auto ElemTypeD = Type::getInt32Ty(F->getParent()->getContext());
-        auto VecTyD = VectorType::get(ElemTypeD, 3);
+        auto VecTyD = IGCLLVM::FixedVectorType::get(ElemTypeD, 3);
         unsigned int Offset = GLOBAL_STATE_FIELD_OFFSETS::LOCAL_SIZE_X;
         unsigned int Size = sizeof(uint32_t) * 3;
         auto LoadInst = BuildLoadInst(CI, Offset, Size, VecTyD);
@@ -495,12 +496,12 @@ Value* WIFuncResolution::getGlobalOffset(CallInst& CI)
     {
         llvm::IRBuilder<> Builder(&CI);
         auto ElemTypeQ = Type::getInt64Ty(F->getParent()->getContext());
-        auto VecTyQ = VectorType::get(ElemTypeQ, 3);
+        auto VecTyQ = IGCLLVM::FixedVectorType::get(ElemTypeQ, 3);
         unsigned int Offset = GLOBAL_STATE_FIELD_OFFSETS::GLOBAL_OFFSET_X;
         unsigned int Size = sizeof(uint64_t) * 3;
         auto LoadInst = BuildLoadInst(CI, Offset, Size, VecTyQ);
         auto ElemType = CI.getType();
-        Value* Undef = UndefValue::get(VectorType::get(ElemType, 3));
+        Value* Undef = UndefValue::get(IGCLLVM::FixedVectorType::get(ElemType, 3));
         for (unsigned int I = 0; I != 3; ++I)
         {
             // Extract each dimension, truncate to i32, then insert in new vector
@@ -565,7 +566,7 @@ Value* WIFuncResolution::getNumGroups(CallInst& CI)
     {
         llvm::IRBuilder<> Builder(&CI);
         auto ElemTypeUD = Type::getInt32Ty(F->getParent()->getContext());
-        auto VecTyUD = VectorType::get(ElemTypeUD, 3);
+        auto VecTyUD = IGCLLVM::FixedVectorType::get(ElemTypeUD, 3);
         unsigned int Offset = GLOBAL_STATE_FIELD_OFFSETS::GROUP_COUNT_X;
         unsigned int Size = sizeof(uint32_t) * 3;
         auto LoadInst = BuildLoadInst(CI, Offset, Size, VecTyUD);
@@ -615,12 +616,12 @@ Value* WIFuncResolution::getStageInGridSize(CallInst& CI)
     {
         llvm::IRBuilder<> Builder(&CI);
         auto ElemTypeQ = Type::getInt64Ty(F->getParent()->getContext());
-        auto VecTyQ = VectorType::get(ElemTypeQ, 3);
+        auto VecTyQ = IGCLLVM::FixedVectorType::get(ElemTypeQ, 3);
         unsigned int Offset = GLOBAL_STATE_FIELD_OFFSETS::GLOBAL_SIZE_X;
         unsigned int Size = sizeof(uint64_t) * 3;
         auto LoadInst = BuildLoadInst(CI, Offset, Size, VecTyQ);
         auto ElemType = Type::getInt32Ty(F->getParent()->getContext());
-        Value* Undef = UndefValue::get(VectorType::get(ElemType, 3));
+        Value* Undef = UndefValue::get(IGCLLVM::FixedVectorType::get(ElemType, 3));
         for (unsigned int I = 0; I != 3; ++I)
         {
             // Extract each dimension, truncate to i32, then insert in new vector
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXLegalization.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXLegalization.cpp
index fd2f43c21..48d5d66c5 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXLegalization.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXLegalization.cpp
@@ -2092,7 +2092,7 @@ static Type *getNewVectorType(Type *OldTy, IntegerType *NewScalarType) {
   unsigned NewElemSize = NewScalarType->getBitWidth();
   if (OldElemSize * OldNumElems % NewElemSize)
     return nullptr;
-  return VectorType::get(NewScalarType,
+  return IGCLLVM::FixedVectorType::get(NewScalarType,
                          OldElemSize * OldNumElems / NewElemSize);
 }
 
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXPatternMatch.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXPatternMatch.cpp
index 9c80b5f32..da0e4bdce 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXPatternMatch.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXPatternMatch.cpp
@@ -2145,7 +2145,7 @@ static bool mergeToWrRegion(SelectInst *SI) {
       Value *Mask = SI->getCondition();
       // Invert mask if needed.
       if (Inverted)
-        Mask = invertCondition(Mask);
+        Mask = llvm::genx::invertCondition(Mask);
       // Create new wrregion.
       Region WrReg(Wr, BaleInfo());
       WrReg.Mask = Mask;
@@ -2280,11 +2280,9 @@ static void decomposeSdivPow2(Instruction &Sdiv,
   Builder.SetCurrentDebugLocation(Sdiv.getDebugLoc());
 
   auto createConstant = [](unsigned int OperandWidth, Type *Ty, int Value) {
-    return OperandWidth != 0 ? ConstantDataVector::getSplat(
-                                   IGCLLVM::getElementCount(OperandWidth),
-                                   ConstantInt::get(Ty, Value))
-                             : ConstantInt::get(Ty, Value);
-    ;
+    return OperandWidth != 0 ?
+        ConstantDataVector::getSplat(OperandWidth, ConstantInt::get(Ty, Value)) :
+        ConstantInt::get(Ty, Value);
   };
 
   Constant *VecSignBit =
diff --git a/IGC/VectorCompiler/lib/GenXCodeGen/GenXThreadPrivateMemory.cpp b/IGC/VectorCompiler/lib/GenXCodeGen/GenXThreadPrivateMemory.cpp
index 135868a84..32d08ec3b 100644
--- a/IGC/VectorCompiler/lib/GenXCodeGen/GenXThreadPrivateMemory.cpp
+++ b/IGC/VectorCompiler/lib/GenXCodeGen/GenXThreadPrivateMemory.cpp
@@ -362,7 +362,7 @@ Value *GenXThreadPrivateMemory::lookForPtrReplacement(Value *Ptr) const {
   if (isa<UndefValue>(Ptr)) {
     if (auto PtrVecTy = dyn_cast<VectorType>(PtrTy))
       return UndefValue::get(
-          VectorType::get(MemTy, PtrVecTy->getNumElements()));
+          IGCLLVM::FixedVectorType::get(MemTy, PtrVecTy->getNumElements()));
     return UndefValue::get(MemTy);
   } else if (auto BC = dyn_cast<BitCastInst>(Ptr))
     return lookForPtrReplacement(BC->getOperand(0));
@@ -470,7 +470,7 @@ bool GenXThreadPrivateMemory::replaceShuffleVector(
   Value *NewVec1 = lookForPtrReplacement(Vec1);
   Value *NewVec2 = lookForPtrReplacement(Vec2);
   auto NewShuffleVec = new ShuffleVectorInst(
-      NewVec1, NewVec2, ShuffleVec->getMask(), ShuffleVec->getName() + ".tpm");
+      NewVec1, NewVec2, IGCLLVM::getShuffleMaskForBitcode(ShuffleVec), ShuffleVec->getName() + ".tpm");
   NewShuffleVec->insertAfter(ShuffleVec);
 
   auto CastToOldTy =
diff --git a/IGC/WrapperLLVM/CMakeLists.txt b/IGC/WrapperLLVM/CMakeLists.txt
index d96b47068..8b768aa83 100644
--- a/IGC/WrapperLLVM/CMakeLists.txt
+++ b/IGC/WrapperLLVM/CMakeLists.txt
@@ -40,6 +40,7 @@ set(IGC_WrapperLLVM_HDR
     "${CMAKE_CURRENT_SOURCE_DIR}/include/llvmWrapper/IR/IRBuilder.h"
     "${CMAKE_CURRENT_SOURCE_DIR}/include/llvmWrapper/IR/CallSite.h"
     "${CMAKE_CURRENT_SOURCE_DIR}/include/llvmWrapper/IR/CFG.h"
+    "${CMAKE_CURRENT_SOURCE_DIR}/include/llvmWrapper/IR/DataLayout.h"
     "${CMAKE_CURRENT_SOURCE_DIR}/include/llvmWrapper/IR/DerivedTypes.h"
     "${CMAKE_CURRENT_SOURCE_DIR}/include/llvmWrapper/IR/DIBuilder.h"
     "${CMAKE_CURRENT_SOURCE_DIR}/include/llvmWrapper/IR/Instructions.h"
diff --git a/IGC/WrapperLLVM/include/llvmWrapper/IR/DataLayout.h b/IGC/WrapperLLVM/include/llvmWrapper/IR/DataLayout.h
new file mode 100644
index 000000000..ea76a64b3
--- /dev/null
+++ b/IGC/WrapperLLVM/include/llvmWrapper/IR/DataLayout.h
@@ -0,0 +1,54 @@
+/*===================== begin_copyright_notice ==================================
+
+Copyright (c) 2017 Intel Corporation
+
+Permission is hereby granted, free of charge, to any person obtaining a
+copy of this software and associated documentation files (the
+"Software"), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be included
+in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+
+======================= end_copyright_notice ==================================*/
+
+#ifndef IGCLLVM_IR_DATALAYOUT_H
+#define IGCLLVM_IR_DATALAYOUT_H
+
+#include "llvm/IR/DataLayout.h"
+#include "llvm/Config/llvm-config.h"
+
+namespace IGCLLVM {
+
+/* * * * *
+ * This section provides compatibility for deprecated
+ * unsigned llvm::DataLayout::getPreferredAlignment().
+ *
+ * In LLVM 10 and earlier llvm::Align was not standarized yet and getPreferredAlignment()
+ * was used, which returned unsigned.
+ */
+#if LLVM_VERSION_MAJOR <= 10
+    unsigned getPreferredAlignValue(llvm::DataLayout* DL, const llvm::GlobalVariable* GV) {
+        return DL->getPreferredAlignment(GV);
+    }
+#else
+    unsigned getPreferredAlignValue(llvm::DataLayout * DL, const llvm::GlobalVariable * GV) {
+        return DL->getPreferredAlign(GV).value();
+    }
+#endif
+
+} // namespace IGCLLVM
+
+#endif
diff --git a/IGC/WrapperLLVM/include/llvmWrapper/Support/Alignment.h b/IGC/WrapperLLVM/include/llvmWrapper/Support/Alignment.h
index 6cf5f06dd..00079a89f 100644
--- a/IGC/WrapperLLVM/include/llvmWrapper/Support/Alignment.h
+++ b/IGC/WrapperLLVM/include/llvmWrapper/Support/Alignment.h
@@ -96,7 +96,7 @@ namespace IGCLLVM {
 #elif LLVM_VERSION_MAJOR <= 10
         return llvm::MaybeAlign(Val.getAlignment());
 #else
-        return Val.getAlign();
+        return llvm::Align(Val.getAlignment());
 #endif
     }
 
