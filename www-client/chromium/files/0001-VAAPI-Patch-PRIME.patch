From 166107bcb36f08401ac06d92696cccaa132a2d63 Mon Sep 17 00:00:00 2001
From: Mike Lothian <mike@fireburn.co.uk>
Date: Thu, 16 May 2019 22:54:40 +0100
Subject: [PATCH] VAAPI Patch PRIME

---
 chrome/browser/about_flags.cc                 |  6 +--
 chrome/browser/flag_descriptions.cc           | 10 +++--
 chrome/browser/flag_descriptions.h            | 10 +++--
 content/gpu/BUILD.gn                          |  5 +++
 content/gpu/gpu_sandbox_hook_linux.cc         |  2 +
 gpu/config/software_rendering_list.json       | 11 -----
 media/base/media_switches.cc                  |  2 +-
 media/filters/BUILD.gn                        |  3 +-
 media/gpu/BUILD.gn                            |  1 +
 .../gpu_video_decode_accelerator_factory.cc   |  3 ++
 .../service/gpu_video_decode_accelerator.cc   |  2 +
 .../vaapi/vaapi_video_decode_accelerator.cc   | 15 +++++++
 media/gpu/vaapi/vaapi_wrapper.cc              | 40 ++++++++++++++-----
 13 files changed, 78 insertions(+), 32 deletions(-)

diff --git a/chrome/browser/about_flags.cc b/chrome/browser/about_flags.cc
index d7bdbe5fb..8aa4d50fa 100644
--- a/chrome/browser/about_flags.cc
+++ b/chrome/browser/about_flags.cc
@@ -1367,7 +1367,7 @@ const FeatureEntry kFeatureEntries[] = {
         "disable-accelerated-video-decode",
         flag_descriptions::kAcceleratedVideoDecodeName,
         flag_descriptions::kAcceleratedVideoDecodeDescription,
-        kOsMac | kOsWin | kOsCrOS | kOsAndroid,
+        kOsAll,
         SINGLE_DISABLE_VALUE_TYPE(switches::kDisableAcceleratedVideoDecode),
     },
 #if defined(OS_WIN)
@@ -1856,10 +1856,10 @@ const FeatureEntry kFeatureEntries[] = {
      FEATURE_VALUE_TYPE(service_manager::features::kXRSandbox)},
 #endif  // ENABLE_ISOLATED_XR_SERVICE
 #endif  // ENABLE_VR
-#if defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && !defined(OS_ANDROID)
     {"disable-accelerated-mjpeg-decode",
      flag_descriptions::kAcceleratedMjpegDecodeName,
-     flag_descriptions::kAcceleratedMjpegDecodeDescription, kOsCrOS,
+     flag_descriptions::kAcceleratedMjpegDecodeDescription, kOsCrOS | kOsLinux,
      SINGLE_DISABLE_VALUE_TYPE(switches::kDisableAcceleratedMjpegDecode)},
 #endif  // OS_CHROMEOS
     {"v8-cache-options", flag_descriptions::kV8CacheOptionsName,
diff --git a/chrome/browser/flag_descriptions.cc b/chrome/browser/flag_descriptions.cc
index 376e7a567..d4d025f5e 100644
--- a/chrome/browser/flag_descriptions.cc
+++ b/chrome/browser/flag_descriptions.cc
@@ -2926,9 +2926,7 @@ const char kMacSystemMediaPermissionsInfoUiDescription[] =
 
 #endif
 
-// Chrome OS -------------------------------------------------------------------
-
-#if defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && !defined(OS_ANDROID)
 
 const char kAcceleratedMjpegDecodeName[] =
     "Hardware-accelerated mjpeg decode for captured frame";
@@ -2936,6 +2934,12 @@ const char kAcceleratedMjpegDecodeDescription[] =
     "Enable hardware-accelerated mjpeg decode for captured frame where "
     "available.";
 
+#endif
+
+// Chrome OS -------------------------------------------------------------------
+
+#if defined(OS_CHROMEOS)
+
 const char kAppServiceAshName[] = "App Service Ash";
 const char kAppServiceAshDescription[] =
     "Use the App Service to provide data to the Ash UI, such as the shelf and "
diff --git a/chrome/browser/flag_descriptions.h b/chrome/browser/flag_descriptions.h
index a3ebea5f1..0575e8f95 100644
--- a/chrome/browser/flag_descriptions.h
+++ b/chrome/browser/flag_descriptions.h
@@ -1756,13 +1756,17 @@ extern const char kPermissionPromptPersistenceToggleDescription[];
 
 #endif  // defined(OS_MACOSX)
 
-// Chrome OS ------------------------------------------------------------------
-
-#if defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && !defined(OS_ANDROID)
 
 extern const char kAcceleratedMjpegDecodeName[];
 extern const char kAcceleratedMjpegDecodeDescription[];
 
+#endif
+
+// Chrome OS ------------------------------------------------------------------
+
+#if defined(OS_CHROMEOS)
+
 extern const char kAppServiceAshName[];
 extern const char kAppServiceAshDescription[];
 
diff --git a/content/gpu/BUILD.gn b/content/gpu/BUILD.gn
index 2b1165264..9f5ab9016 100644
--- a/content/gpu/BUILD.gn
+++ b/content/gpu/BUILD.gn
@@ -6,6 +6,7 @@ import("//build/config/jumbo.gni")
 import("//build/config/ui.gni")
 import("//gpu/vulkan/features.gni")
 import("//media/media_options.gni")
+import("//media/gpu/args.gni")
 import("//ui/ozone/ozone.gni")
 
 # See //content/BUILD.gn for how this works.
@@ -127,4 +128,8 @@ target(link_target_type, "gpu_sources") {
       (!is_chromecast || is_cast_desktop_build)) {
     configs += [ "//build/config/linux/dri" ]
   }
+
+  if (is_desktop_linux && use_vaapi) {
+    public_configs = [ "//build/config/linux/libva" ]
+  }
 }
diff --git a/content/gpu/gpu_sandbox_hook_linux.cc b/content/gpu/gpu_sandbox_hook_linux.cc
index 6f4ef48f9..044a23872 100644
--- a/content/gpu/gpu_sandbox_hook_linux.cc
+++ b/content/gpu/gpu_sandbox_hook_linux.cc
@@ -158,9 +158,11 @@ void AddAmdGpuWhitelist(std::vector<BrokerFilePermission>* permissions) {
       "/dev/dri/card0",
       "/dev/dri/controlD64",
       "/dev/dri/renderD128",
+      "/dev/dri/renderD129",
       "/sys/class/drm/card0/device/config",
       "/sys/class/drm/controlD64/device/config",
       "/sys/class/drm/renderD128/device/config",
+      "/sys/class/drm/renderD129/device/config",
       "/usr/share/libdrm/amdgpu.ids"};
   for (const char* item : kReadWriteList)
     permissions->push_back(BrokerFilePermission::ReadWrite(item));
diff --git a/gpu/config/software_rendering_list.json b/gpu/config/software_rendering_list.json
index d4c3b4364..935fdeb86 100644
--- a/gpu/config/software_rendering_list.json
+++ b/gpu/config/software_rendering_list.json
@@ -369,17 +369,6 @@
         "all"
       ]
     },
-    {
-      "id": 48,
-      "description": "Accelerated video decode is unavailable on Linux",
-      "cr_bugs": [137247],
-      "os": {
-        "type": "linux"
-      },
-      "features": [
-        "accelerated_video_decode"
-      ]
-    },
     {
       "id": 50,
       "description": "Disable VMware software renderer on older Mesa",
diff --git a/media/base/media_switches.cc b/media/base/media_switches.cc
index 390522cab..f8347a88e 100644
--- a/media/base/media_switches.cc
+++ b/media/base/media_switches.cc
@@ -511,7 +511,7 @@ bool IsVideoCaptureAcceleratedJpegDecodingEnabled() {
           switches::kUseFakeMjpegDecodeAccelerator)) {
     return true;
   }
-#if defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && !defined(OS_ANDROID)
   return true;
 #endif
   return false;
diff --git a/media/filters/BUILD.gn b/media/filters/BUILD.gn
index ed193cb08..2b6ad7670 100644
--- a/media/filters/BUILD.gn
+++ b/media/filters/BUILD.gn
@@ -5,6 +5,7 @@
 import("//build/config/jumbo.gni")
 import("//media/media_options.gni")
 import("//third_party/libaom/options.gni")
+import("//media/gpu/args.gni")
 
 jumbo_source_set("filters") {
   # Do not expand the visibility here without double-checking with OWNERS, this
@@ -212,7 +213,7 @@ jumbo_source_set("filters") {
     deps += [ "//media/base/android" ]
   }
 
-  if (current_cpu != "arm" && is_linux) {
+  if (use_vaapi) {
     sources += [
       "h264_bitstream_buffer.cc",
       "h264_bitstream_buffer.h",
diff --git a/media/gpu/BUILD.gn b/media/gpu/BUILD.gn
index 6eed6db69..65ab4190b 100644
--- a/media/gpu/BUILD.gn
+++ b/media/gpu/BUILD.gn
@@ -580,6 +580,7 @@ if (is_chromeos || is_linux) {
     if (use_ozone) {
       deps += [ "//ui/ozone" ]
     }
+    public_configs = [ "//build/config/linux/libva" ]
   }
 }
 
diff --git a/media/gpu/gpu_video_decode_accelerator_factory.cc b/media/gpu/gpu_video_decode_accelerator_factory.cc
index dc9ff3fb3..6a87f9c27 100644
--- a/media/gpu/gpu_video_decode_accelerator_factory.cc
+++ b/media/gpu/gpu_video_decode_accelerator_factory.cc
@@ -183,6 +183,8 @@ GpuVideoDecodeAcceleratorFactory::CreateVDA(
     vda = (this->*create_vda_function)(workarounds, gpu_preferences, media_log);
     if (vda && vda->Initialize(config, client))
       return vda;
+    else
+      LOG(ERROR) << "Initialization of one or more VDAs failed.";
   }
 
   return nullptr;
@@ -241,6 +243,7 @@ GpuVideoDecodeAcceleratorFactory::CreateVaapiVDA(
     const gpu::GpuDriverBugWorkarounds& workarounds,
     const gpu::GpuPreferences& gpu_preferences,
     MediaLog* media_log) const {
+  LOG(WARNING) << "Initializing VAAPI VDA.";
   std::unique_ptr<VideoDecodeAccelerator> decoder;
   decoder.reset(new VaapiVideoDecodeAccelerator(make_context_current_cb_,
                                                 bind_image_cb_));
diff --git a/media/gpu/ipc/service/gpu_video_decode_accelerator.cc b/media/gpu/ipc/service/gpu_video_decode_accelerator.cc
index 206c9ec59..daa3f5559 100644
--- a/media/gpu/ipc/service/gpu_video_decode_accelerator.cc
+++ b/media/gpu/ipc/service/gpu_video_decode_accelerator.cc
@@ -381,6 +381,7 @@ bool GpuVideoDecodeAccelerator::Initialize(
     LOG(ERROR) << "Failed creating the VDA factory";
     return false;
   }
+  LOG(WARNING) << "Created the VDA factory";
 
   const gpu::GpuDriverBugWorkarounds& gpu_workarounds =
       stub_->channel()->gpu_channel_manager()->gpu_driver_bug_workarounds();
@@ -394,6 +395,7 @@ bool GpuVideoDecodeAccelerator::Initialize(
                << (config.is_encrypted() ? " with encryption" : "");
     return false;
   }
+  LOG(WARNING) << "Created VDA";
 
   // Attempt to set up performing decoding tasks on IO thread, if supported by
   // the VDA.
diff --git a/media/gpu/vaapi/vaapi_video_decode_accelerator.cc b/media/gpu/vaapi/vaapi_video_decode_accelerator.cc
index 2b1ffa1b0..f79db3c76 100644
--- a/media/gpu/vaapi/vaapi_video_decode_accelerator.cc
+++ b/media/gpu/vaapi/vaapi_video_decode_accelerator.cc
@@ -64,6 +64,7 @@ void ReportToUMA(VAVDADecoderFailure failure) {
                             VAVDA_DECODER_FAILURES_MAX + 1);
 }
 
+#if defined(OS_ANDROID) || defined(OS_CHROMEOS)
 // Returns true if the CPU is an Intel Kaby/Gemini/Sky Lake or later.
 // Cpu platform id's are referenced from the following file in kernel source
 // arch/x86/include/asm/intel-family.h
@@ -85,6 +86,7 @@ bool IsGeminiLakeOrLater() {
       cpuid.model() >= kGeminiLakeModelId;
   return is_geminilake_or_later;
 }
+#endif
 
 }  // namespace
 
@@ -634,6 +636,10 @@ void VaapiVideoDecodeAccelerator::AssignPictureBuffers(
   const unsigned int va_format = GetVaFormatForVideoCodecProfile(profile_);
   std::vector<VASurfaceID> va_surface_ids;
 
+  // Nvidia doesn't support VAProfileNone, so don't try to create a temporary
+  // copy buffer there. It's not needed anyways for hardware video decoding
+  // to work.
+#if defined(OS_ANDROID) || defined(OS_CHROMEOS)
   // If we aren't in BufferAllocationMode::kNone, we have to allocate a
   // |vpp_vaapi_wrapper_| for VaapiPicture to DownloadFromSurface() the VA's
   // internal decoded frame.
@@ -647,6 +653,7 @@ void VaapiVideoDecodeAccelerator::AssignPictureBuffers(
       NotifyError(PLATFORM_FAILURE);
     }
   }
+#endif
 
   for (size_t i = 0; i < buffers.size(); ++i) {
     DCHECK(requested_pic_size_ == buffers[i].size());
@@ -655,9 +662,13 @@ void VaapiVideoDecodeAccelerator::AssignPictureBuffers(
     // only used as a copy destination. Therefore, the VaapiWrapper used and
     // owned by |picture| is |vpp_vaapi_wrapper_|.
     std::unique_ptr<VaapiPicture> picture = vaapi_picture_factory_->Create(
+#if defined(OS_LINUX) && !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+            vaapi_wrapper_,
+#else
         (buffer_allocation_mode_ == BufferAllocationMode::kNone)
             ? vaapi_wrapper_
             : vpp_vaapi_wrapper_,
+#endif
         make_context_current_cb_, bind_image_cb_, buffers[i]);
     RETURN_AND_NOTIFY_ON_FAILURE(picture, "Failed creating a VaapiPicture",
                                  PLATFORM_FAILURE, );
@@ -1070,6 +1081,9 @@ VaapiVideoDecodeAccelerator::GetSupportedProfiles() {
 
 VaapiVideoDecodeAccelerator::BufferAllocationMode
 VaapiVideoDecodeAccelerator::DecideBufferAllocationMode() const {
+#if defined(OS_LINUX) && !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+  return BufferAllocationMode::kNormal;
+#else
   // TODO(crbug.com/912295): Enable a better BufferAllocationMode for IMPORT
   // |output_mode_| as well.
   if (output_mode_ == VideoDecodeAccelerator::Config::OutputMode::IMPORT)
@@ -1098,6 +1112,7 @@ VaapiVideoDecodeAccelerator::DecideBufferAllocationMode() const {
     return BufferAllocationMode::kReduced;
 
   return BufferAllocationMode::kSuperReduced;
+#endif
 }
 
 bool VaapiVideoDecodeAccelerator::IsBufferAllocationModeReducedOrSuperReduced()
diff --git a/media/gpu/vaapi/vaapi_wrapper.cc b/media/gpu/vaapi/vaapi_wrapper.cc
index bf80a642a..be6dea675 100644
--- a/media/gpu/vaapi/vaapi_wrapper.cc
+++ b/media/gpu/vaapi/vaapi_wrapper.cc
@@ -265,6 +265,18 @@ void VADisplayState::PreSandboxInitialization() {
       base::File::FLAG_OPEN | base::File::FLAG_READ | base::File::FLAG_WRITE);
   if (drm_file.IsValid())
     VADisplayState::Get()->SetDrmFd(drm_file.GetPlatformFile());
+
+  const char kDriRenderNode1Path[] = "/dev/dri/renderD129";
+  base::File drm_file1 = base::File(
+      base::FilePath::FromUTF8Unsafe(kDriRenderNode1Path),
+      base::File::FLAG_OPEN | base::File::FLAG_READ | base::File::FLAG_WRITE);
+  if (drm_file1.IsValid())
+    VADisplayState::Get()->SetDrmFd(drm_file1.GetPlatformFile());
+
+  const char kNvidiaPath[] = "/dev/dri/nvidiactl";
+  base::File nvidia_file = base::File(
+      base::FilePath::FromUTF8Unsafe(kNvidiaPath),
+      base::File::FLAG_OPEN | base::File::FLAG_READ | base::File::FLAG_WRITE);
 }
 
 VADisplayState::VADisplayState()
@@ -292,9 +304,6 @@ bool VADisplayState::Initialize() {
 }
 
 bool VADisplayState::InitializeOnce() {
-  static_assert(VA_MAJOR_VERSION >= 1 && VA_MINOR_VERSION >= 1,
-                "Requires VA-API >= 1.1.0");
-
   switch (gl::GetGLImplementation()) {
     case gl::kGLImplementationEGLGLES2:
       va_display_ = vaGetDisplayDRM(drm_fd_.get());
@@ -302,10 +311,10 @@ bool VADisplayState::InitializeOnce() {
     case gl::kGLImplementationDesktopGL:
 #if defined(USE_X11)
       va_display_ = vaGetDisplay(gfx::GetXDisplay());
-#else
-      LOG(WARNING) << "VAAPI video acceleration not available without "
-                      "DesktopGL (GLX).";
+      if (vaDisplayIsValid(va_display_))
+        break;
 #endif  // USE_X11
+      va_display_ = vaGetDisplayDRM(drm_fd_.get());
       break;
     // Cannot infer platform from GL, try all available displays
     case gl::kGLImplementationNone:
@@ -338,8 +347,19 @@ bool VADisplayState::InitializeOnce() {
   int major_version, minor_version;
   VAStatus va_res = vaInitialize(va_display_, &major_version, &minor_version);
   if (va_res != VA_STATUS_SUCCESS) {
-    LOG(ERROR) << "vaInitialize failed: " << vaErrorStr(va_res);
-    return false;
+    LOG(ERROR) << "vaInitialize failed (ignore if using Wayland desktop environment): " << vaErrorStr(va_res);
+    va_display_ = vaGetDisplayDRM(drm_fd_.get());
+    if (!vaDisplayIsValid(va_display_)) {
+      LOG(ERROR) << "Could not get a valid DRM VA display";
+      return false;
+    }
+    va_res = vaInitialize(va_display_, &major_version, &minor_version);
+    if (va_res != VA_STATUS_SUCCESS) {
+      LOG(ERROR) << "vaInitialize failed using DRM: " << vaErrorStr(va_res);
+      return false;
+    } else {
+      LOG(WARNING) << "vaInitialize succeeded for DRM";
+    }
   }
 
   va_initialized_ = true;
@@ -347,7 +367,7 @@ bool VADisplayState::InitializeOnce() {
   va_vendor_string_ = vaQueryVendorString(va_display_);
   DLOG_IF(WARNING, va_vendor_string_.empty())
       << "Vendor string empty or error reading.";
-  DVLOG(1) << "VAAPI version: " << major_version << "." << minor_version << " "
+  VLOG(1) << "VAAPI version: " << major_version << "." << minor_version << " "
            << va_vendor_string_;
 
   // The VAAPI version is determined from what is loaded on the system by
@@ -680,7 +700,7 @@ bool VASupportedProfiles::AreAttribsSupported_Locked(
     if (attribs[i].type != required_attribs[i].type ||
         (attribs[i].value & required_attribs[i].value) !=
             required_attribs[i].value) {
-      DVLOG(1) << "Unsupported value " << required_attribs[i].value
+      VLOG(1) << "Unsupported value " << required_attribs[i].value
                << " for attribute type " << required_attribs[i].type;
       return false;
     }
-- 
2.21.0

