From debecc8571d181837cc4d97b34e1ec3cf8aabb19 Mon Sep 17 00:00:00 2001
From: Mike Lothian <mike@fireburn.co.uk>
Date: Fri, 20 Mar 2020 10:28:22 +0000
Subject: [PATCH] Enable VAVDA, VAVEA and VAJDA on linux with VAAPI only

This patch contains all the changes necessary to use VA-API along with
vaapi-driver to run all media use cases supported with hardware acceleration.

It is intended to remain as experimental accessible from chrome://flags on linux.
It requires libva/intel-vaapi-driver to be installed on the system path where
chrome is executed.  Other drivers could be tested if available. Flags are
kept independent for linux, where this feature has to be enabled before
actually using it.  This should not change how other OSes use the flags
already, the new flags will show at the buttom on the section of unavailable
experiments

The changes cover a range of compiler pre-processor flags to enable the stack.
It moves the presandbox operations to the vaapi_wrapper class as the hook function
is available there. vaInit will open driver on the correct installed folder.

chrome flags consolidtation into only two flags for linux.  Mjpeg and accelerated
video are used.  The other flags are kept for ChromeOS and other OSes.

Developer testing was made on skylake hardware, ChromeOS and Ubuntu.

BUG=NONE
TEST="subjective testing with VAVDA,VAVEA and VAJDA, autotest for encoder"
TEST="and decoder hardware accelerated"
TEST="have libva/intel-vaapi-driver installed and not installed in the system"
TEST="repeat on different hardware families"
R=posciak@chromium.org
R=kcwu@chromium.org

Cq-Include-Trybots: master.tryserver.chromium.android:android_optional_gpu_tests_rel;master.tryserver.chromium.linux:linux_optional_gpu_tests_rel;master.tryserver.chromium.mac:mac_optional_gpu_tests_rel;master.tryserver.chromium.win:win_optional_gpu_tests_rel
Change-Id: Ifbbf5c9e5221a8b5733fc6d4d0cf984a1f103171
Signed-off-by: Daniel Charles <daniel.charles@intel.com>
---
 chrome/browser/about_flags.cc                 |  6 ++--
 chrome/browser/flag_descriptions.cc           |  4 +--
 chrome/browser/flag_descriptions.h            | 10 ++++--
 content/gpu/BUILD.gn                          |  5 +++
 gpu/config/software_rendering_list.json       | 16 ---------
 media/base/media_switches.cc                  |  2 +-
 media/filters/BUILD.gn                        |  1 +
 media/gpu/BUILD.gn                            |  1 +
 .../gpu_video_decode_accelerator_factory.cc   |  3 ++
 .../service/gpu_video_decode_accelerator.cc   |  2 ++
 media/gpu/test/BUILD.gn                       |  2 +-
 media/gpu/vaapi/vaapi_picture_tfp.cc          |  2 +-
 .../vaapi/vaapi_video_decode_accelerator.cc   | 15 ++++++++
 media/gpu/vaapi/vaapi_wrapper.cc              | 34 +++++++++++++------
 media/mojo/services/gpu_mojo_media_client.cc  | 10 +++---
 15 files changed, 68 insertions(+), 45 deletions(-)

diff --git a/chrome/browser/about_flags.cc b/chrome/browser/about_flags.cc
index b3f2caef82..ecb4d6dacf 100644
--- a/chrome/browser/about_flags.cc
+++ b/chrome/browser/about_flags.cc
@@ -1916,7 +1916,7 @@ const FeatureEntry kFeatureEntries[] = {
         "disable-accelerated-video-decode",
         flag_descriptions::kAcceleratedVideoDecodeName,
         flag_descriptions::kAcceleratedVideoDecodeDescription,
-        kOsMac | kOsWin | kOsCrOS | kOsAndroid,
+        kOsAll,
         SINGLE_DISABLE_VALUE_TYPE(switches::kDisableAcceleratedVideoDecode),
     },
     {
@@ -2348,10 +2348,10 @@ const FeatureEntry kFeatureEntries[] = {
      FEATURE_VALUE_TYPE(service_manager::features::kXRSandbox)},
 #endif  // !defined(OS_ANDROID)
 #endif  // ENABLE_VR
-#if defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && !defined(OS_ANDROID)
     {"disable-accelerated-mjpeg-decode",
      flag_descriptions::kAcceleratedMjpegDecodeName,
-     flag_descriptions::kAcceleratedMjpegDecodeDescription, kOsCrOS,
+     flag_descriptions::kAcceleratedMjpegDecodeDescription, kOsCrOS | kOsLinux,
      SINGLE_DISABLE_VALUE_TYPE(switches::kDisableAcceleratedMjpegDecode)},
 #endif  // OS_CHROMEOS
     {"system-keyboard-lock", flag_descriptions::kSystemKeyboardLockName,
diff --git a/chrome/browser/flag_descriptions.cc b/chrome/browser/flag_descriptions.cc
index a10dfbc251..dff6295e43 100644
--- a/chrome/browser/flag_descriptions.cc
+++ b/chrome/browser/flag_descriptions.cc
@@ -2993,9 +2993,7 @@ const char kMetalDescription[] =
 
 #endif
 
-// Chrome OS -------------------------------------------------------------------
-
-#if defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && !defined(OS_ANDROID)
 
 const char kAcceleratedMjpegDecodeName[] =
     "Hardware-accelerated mjpeg decode for captured frame";
diff --git a/chrome/browser/flag_descriptions.h b/chrome/browser/flag_descriptions.h
index ddd4dabd09..3d22a2676c 100644
--- a/chrome/browser/flag_descriptions.h
+++ b/chrome/browser/flag_descriptions.h
@@ -1727,13 +1727,17 @@ extern const char kMetalDescription[];
 
 #endif  // defined(OS_MACOSX)
 
-// Chrome OS ------------------------------------------------------------------
-
-#if defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && !defined(OS_ANDROID)
 
 extern const char kAcceleratedMjpegDecodeName[];
 extern const char kAcceleratedMjpegDecodeDescription[];
 
+#endif
+
+// Chrome OS ------------------------------------------------------------------
+
+#if defined(OS_CHROMEOS)
+
 extern const char kAggregatedMlAppRankingName[];
 extern const char kAggregatedMlAppRankingDescription[];
 
diff --git a/content/gpu/BUILD.gn b/content/gpu/BUILD.gn
index 088c791f05..531b445407 100644
--- a/content/gpu/BUILD.gn
+++ b/content/gpu/BUILD.gn
@@ -6,6 +6,7 @@ import("//build/config/jumbo.gni")
 import("//build/config/ui.gni")
 import("//gpu/vulkan/features.gni")
 import("//media/media_options.gni")
+import("//media/gpu/args.gni")
 import("//ui/ozone/ozone.gni")
 
 # See //content/BUILD.gn for how this works.
@@ -131,4 +132,8 @@ target(link_target_type, "gpu_sources") {
       (!is_chromecast || is_cast_desktop_build)) {
     configs += [ "//build/config/linux/dri" ]
   }
+
+  if (is_desktop_linux && use_vaapi) {
+    public_configs = [ "//build/config/linux/libva" ]
+  }
 }
diff --git a/gpu/config/software_rendering_list.json b/gpu/config/software_rendering_list.json
index 22712bdbf3..a06dd19a50 100644
--- a/gpu/config/software_rendering_list.json
+++ b/gpu/config/software_rendering_list.json
@@ -335,22 +335,6 @@
         "all"
       ]
     },
-    {
-      "id": 48,
-      "description": "Accelerated video decode is unavailable on Linux",
-      "cr_bugs": [137247, 1032907],
-      "os": {
-        "type": "linux"
-      },
-      "exceptions": [
-        {
-          "machine_model_name": ["Chromecast"]
-        }
-      ],
-      "features": [
-        "accelerated_video_decode"
-      ]
-    },
     {
       "id": 50,
       "description": "Disable VMware software renderer on older Mesa",
diff --git a/media/base/media_switches.cc b/media/base/media_switches.cc
index ff762892dc..71959740ed 100644
--- a/media/base/media_switches.cc
+++ b/media/base/media_switches.cc
@@ -680,7 +680,7 @@ bool IsVideoCaptureAcceleratedJpegDecodingEnabled() {
           switches::kUseFakeMjpegDecodeAccelerator)) {
     return true;
   }
-#if defined(OS_CHROMEOS)
+#if defined(OS_LINUX) && !defined(OS_ANDROID)
   return true;
 #endif
   return false;
diff --git a/media/filters/BUILD.gn b/media/filters/BUILD.gn
index 32cd60069b..5e52d508b3 100644
--- a/media/filters/BUILD.gn
+++ b/media/filters/BUILD.gn
@@ -6,6 +6,7 @@ import("//build/config/jumbo.gni")
 import("//media/gpu/args.gni")
 import("//media/media_options.gni")
 import("//third_party/libaom/options.gni")
+import("//media/gpu/args.gni")
 
 jumbo_source_set("filters") {
   # Do not expand the visibility here without double-checking with OWNERS, this
diff --git a/media/gpu/BUILD.gn b/media/gpu/BUILD.gn
index 237cf96dd8..9d70bd32e3 100644
--- a/media/gpu/BUILD.gn
+++ b/media/gpu/BUILD.gn
@@ -449,6 +449,7 @@ if (use_v4l2_codec || use_vaapi || is_mac || is_win) {
     if (use_ozone) {
       deps += [ "//ui/ozone" ]
     }
+    public_configs = [ "//build/config/linux/libva" ]
   }
 }
 
diff --git a/media/gpu/gpu_video_decode_accelerator_factory.cc b/media/gpu/gpu_video_decode_accelerator_factory.cc
index a5d4a3dfcc..9ed1f98c31 100644
--- a/media/gpu/gpu_video_decode_accelerator_factory.cc
+++ b/media/gpu/gpu_video_decode_accelerator_factory.cc
@@ -185,6 +185,8 @@ GpuVideoDecodeAcceleratorFactory::CreateVDA(
     vda = (this->*create_vda_function)(workarounds, gpu_preferences, media_log);
     if (vda && vda->Initialize(config, client))
       return vda;
+    else
+      LOG(ERROR) << "Initialization of one or more VDAs failed.";
   }
 
   return nullptr;
@@ -243,6 +245,7 @@ GpuVideoDecodeAcceleratorFactory::CreateVaapiVDA(
     const gpu::GpuDriverBugWorkarounds& workarounds,
     const gpu::GpuPreferences& gpu_preferences,
     MediaLog* media_log) const {
+  LOG(WARNING) << "Initializing VAAPI VDA.";
   std::unique_ptr<VideoDecodeAccelerator> decoder;
   decoder.reset(new VaapiVideoDecodeAccelerator(make_context_current_cb_,
                                                 bind_image_cb_));
diff --git a/media/gpu/ipc/service/gpu_video_decode_accelerator.cc b/media/gpu/ipc/service/gpu_video_decode_accelerator.cc
index aab498b598..e80a10288d 100644
--- a/media/gpu/ipc/service/gpu_video_decode_accelerator.cc
+++ b/media/gpu/ipc/service/gpu_video_decode_accelerator.cc
@@ -380,6 +380,7 @@ bool GpuVideoDecodeAccelerator::Initialize(
     LOG(ERROR) << "Failed creating the VDA factory";
     return false;
   }
+  LOG(WARNING) << "Created the VDA factory";
 
   const gpu::GpuDriverBugWorkarounds& gpu_workarounds =
       stub_->channel()->gpu_channel_manager()->gpu_driver_bug_workarounds();
@@ -393,6 +394,7 @@ bool GpuVideoDecodeAccelerator::Initialize(
                << (config.is_encrypted() ? " with encryption" : "");
     return false;
   }
+  LOG(WARNING) << "Created VDA";
 
   // Attempt to set up performing decoding tasks on IO thread, if supported by
   // the VDA.
diff --git a/media/gpu/test/BUILD.gn b/media/gpu/test/BUILD.gn
index b276f93537..11391e5ca2 100644
--- a/media/gpu/test/BUILD.gn
+++ b/media/gpu/test/BUILD.gn
@@ -150,7 +150,7 @@ if (use_vaapi || use_v4l2_codec) {
   }
 }
 
-if (is_chromeos) {
+if (use_vaapi || is_chromeos) {
   static_library("local_gpu_memory_buffer_manager") {
     testonly = true
     sources = [
diff --git a/media/gpu/vaapi/vaapi_picture_tfp.cc b/media/gpu/vaapi/vaapi_picture_tfp.cc
index 227c31b18b..b42620d745 100644
--- a/media/gpu/vaapi/vaapi_picture_tfp.cc
+++ b/media/gpu/vaapi/vaapi_picture_tfp.cc
@@ -57,7 +57,7 @@ bool VaapiTFPPicture::Initialize() {
   if (make_context_current_cb_ && !make_context_current_cb_.Run())
     return false;
 
-  glx_image_ = new gl::GLImageGLX(size_, GL_RGB);
+  glx_image_ = new gl::GLImageGLX(size_, gfx::BufferFormat::BGRX_8888);
   if (!glx_image_->Initialize(x_pixmap_)) {
     // x_pixmap_ will be freed in the destructor.
     DLOG(ERROR) << "Failed creating a GLX Pixmap for TFP";
diff --git a/media/gpu/vaapi/vaapi_video_decode_accelerator.cc b/media/gpu/vaapi/vaapi_video_decode_accelerator.cc
index f8e0c5bf9c..f5d68ed279 100644
--- a/media/gpu/vaapi/vaapi_video_decode_accelerator.cc
+++ b/media/gpu/vaapi/vaapi_video_decode_accelerator.cc
@@ -63,6 +63,7 @@ void ReportToUMA(VAVDADecoderFailure failure) {
                             VAVDA_DECODER_FAILURES_MAX + 1);
 }
 
+#if defined(OS_ANDROID) || defined(OS_CHROMEOS)
 // Returns true if the CPU is an Intel Gemini Lake or later (including Kaby
 // Lake) Cpu platform id's are referenced from the following file in kernel
 // source arch/x86/include/asm/intel-family.h
@@ -75,6 +76,7 @@ bool IsGeminiLakeOrLater() {
       cpuid.model() >= kGeminiLakeModelId;
   return is_geminilake_or_later;
 }
+#endif
 
 // Returns the size of a rectangle whose upper left corner is at the origin (0,
 // 0) and whose bottom right corner is the same as that of |rect|. This is
@@ -708,6 +710,10 @@ void VaapiVideoDecodeAccelerator::AssignPictureBuffers(
   va_surface_format_ = GetVaFormatForVideoCodecProfile(profile_);
   std::vector<VASurfaceID> va_surface_ids;
 
+  // Nvidia doesn't support VAProfileNone, so don't try to create a temporary
+  // copy buffer there. It's not needed anyways for hardware video decoding
+  // to work.
+#if defined(OS_ANDROID) || defined(OS_CHROMEOS)
   // If we aren't in BufferAllocationMode::kNone, we have to allocate a
   // |vpp_vaapi_wrapper_| for VaapiPicture to DownloadFromSurface() the VA's
   // internal decoded frame.
@@ -725,6 +731,7 @@ void VaapiVideoDecodeAccelerator::AssignPictureBuffers(
                                  "Failed to create Context",
                                  PLATFORM_FAILURE, );
   }
+#endif
 
   for (size_t i = 0; i < buffers.size(); ++i) {
     // If we aren't in BufferAllocationMode::kNone, this |picture| is
@@ -743,9 +750,13 @@ void VaapiVideoDecodeAccelerator::AssignPictureBuffers(
             : gfx::Size();
 
     std::unique_ptr<VaapiPicture> picture = vaapi_picture_factory_->Create(
+#if defined(OS_LINUX) && !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+            vaapi_wrapper_,
+#else
         (buffer_allocation_mode_ == BufferAllocationMode::kNone)
             ? vaapi_wrapper_
             : vpp_vaapi_wrapper_,
+#endif
         make_context_current_cb_, bind_image_cb_, buffer, size_to_bind);
     RETURN_AND_NOTIFY_ON_FAILURE(picture, "Failed creating a VaapiPicture",
                                  PLATFORM_FAILURE, );
@@ -1199,6 +1210,9 @@ VaapiVideoDecodeAccelerator::GetSupportedProfiles() {
 
 VaapiVideoDecodeAccelerator::BufferAllocationMode
 VaapiVideoDecodeAccelerator::DecideBufferAllocationMode() {
+#if defined(OS_LINUX) && !defined(OS_ANDROID) && !defined(OS_CHROMEOS)
+  return BufferAllocationMode::kNormal;
+#else
   // TODO(crbug.com/912295): Enable a better BufferAllocationMode for IMPORT
   // |output_mode_| as well.
   if (output_mode_ == VideoDecodeAccelerator::Config::OutputMode::IMPORT)
@@ -1234,6 +1248,7 @@ VaapiVideoDecodeAccelerator::DecideBufferAllocationMode() {
     return BufferAllocationMode::kReduced;
 
   return BufferAllocationMode::kSuperReduced;
+#endif
 }
 
 bool VaapiVideoDecodeAccelerator::IsBufferAllocationModeReducedOrSuperReduced()
diff --git a/media/gpu/vaapi/vaapi_wrapper.cc b/media/gpu/vaapi/vaapi_wrapper.cc
index dce9d93d32..80e6c685f7 100644
--- a/media/gpu/vaapi/vaapi_wrapper.cc
+++ b/media/gpu/vaapi/vaapi_wrapper.cc
@@ -405,6 +405,11 @@ void VADisplayState::PreSandboxInitialization() {
       base::File::FLAG_OPEN | base::File::FLAG_READ | base::File::FLAG_WRITE);
   if (drm_file.IsValid())
     VADisplayState::Get()->SetDrmFd(drm_file.GetPlatformFile());
+
+  const char kNvidiaPath[] = "/dev/dri/nvidiactl";
+  base::File nvidia_file = base::File(
+      base::FilePath::FromUTF8Unsafe(kNvidiaPath),
+      base::File::FLAG_OPEN | base::File::FLAG_READ | base::File::FLAG_WRITE);
 }
 
 VADisplayState::VADisplayState()
@@ -432,10 +437,6 @@ bool VADisplayState::Initialize() {
 }
 
 bool VADisplayState::InitializeOnce() {
-  static_assert(
-      VA_MAJOR_VERSION >= 2 || (VA_MAJOR_VERSION == 1 && VA_MINOR_VERSION >= 1),
-      "Requires VA-API >= 1.1.0");
-
   switch (gl::GetGLImplementation()) {
     case gl::kGLImplementationEGLGLES2:
       va_display_ = vaGetDisplayDRM(drm_fd_.get());
@@ -443,10 +444,10 @@ bool VADisplayState::InitializeOnce() {
     case gl::kGLImplementationDesktopGL:
 #if defined(USE_X11)
       va_display_ = vaGetDisplay(gfx::GetXDisplay());
-#else
-      LOG(WARNING) << "VAAPI video acceleration not available without "
-                      "DesktopGL (GLX).";
+      if (vaDisplayIsValid(va_display_))
+        break;
 #endif  // USE_X11
+      va_display_ = vaGetDisplayDRM(drm_fd_.get());
       break;
     // Cannot infer platform from GL, try all available displays
     case gl::kGLImplementationNone:
@@ -479,8 +480,19 @@ bool VADisplayState::InitializeOnce() {
   int major_version, minor_version;
   VAStatus va_res = vaInitialize(va_display_, &major_version, &minor_version);
   if (va_res != VA_STATUS_SUCCESS) {
-    LOG(ERROR) << "vaInitialize failed: " << vaErrorStr(va_res);
-    return false;
+    LOG(ERROR) << "vaInitialize failed (ignore if using Wayland desktop environment): " << vaErrorStr(va_res);
+    va_display_ = vaGetDisplayDRM(drm_fd_.get());
+    if (!vaDisplayIsValid(va_display_)) {
+      LOG(ERROR) << "Could not get a valid DRM VA display";
+      return false;
+    }
+    va_res = vaInitialize(va_display_, &major_version, &minor_version);
+    if (va_res != VA_STATUS_SUCCESS) {
+      LOG(ERROR) << "vaInitialize failed using DRM: " << vaErrorStr(va_res);
+      return false;
+    } else {
+      LOG(WARNING) << "vaInitialize succeeded for DRM";
+    }
   }
 
   va_initialized_ = true;
@@ -488,7 +500,7 @@ bool VADisplayState::InitializeOnce() {
   va_vendor_string_ = vaQueryVendorString(va_display_);
   DLOG_IF(WARNING, va_vendor_string_.empty())
       << "Vendor string empty or error reading.";
-  DVLOG(1) << "VAAPI version: " << major_version << "." << minor_version << " "
+  VLOG(1) << "VAAPI version: " << major_version << "." << minor_version << " "
            << va_vendor_string_;
 
   // The VAAPI version is determined from what is loaded on the system by
@@ -829,7 +841,7 @@ bool VASupportedProfiles::AreAttribsSupported_Locked(
     if (attribs[i].type != required_attribs[i].type ||
         (attribs[i].value & required_attribs[i].value) !=
             required_attribs[i].value) {
-      DVLOG(1) << "Unsupported value " << required_attribs[i].value
+      VLOG(1) << "Unsupported value " << required_attribs[i].value
                << " for attribute type " << required_attribs[i].type;
       return false;
     }
diff --git a/media/mojo/services/gpu_mojo_media_client.cc b/media/mojo/services/gpu_mojo_media_client.cc
index 6654fa8a5a..5a0023efa4 100644
--- a/media/mojo/services/gpu_mojo_media_client.cc
+++ b/media/mojo/services/gpu_mojo_media_client.cc
@@ -118,9 +118,9 @@ GpuMojoMediaClient::GpuMojoMediaClient(
       gpu_task_runner_(std::move(gpu_task_runner)),
       media_gpu_channel_manager_(std::move(media_gpu_channel_manager)),
       android_overlay_factory_cb_(std::move(android_overlay_factory_cb)),
-#if defined(OS_CHROMEOS) && BUILDFLAG(USE_CHROMEOS_MEDIA_ACCELERATION)
+#if defined(USE_CHROMEOS_MEDIA_ACCELERATION)
       gpu_memory_buffer_factory_(gpu_memory_buffer_factory),
-#endif  // defined(OS_CHROMEOS) && BUILDFLAG(USE_CHROMEOS_MEDIA_ACCELERATION)
+#endif  // defined(USE_CHROMEOS_MEDIA_ACCELERATION)
       cdm_proxy_factory_cb_(std::move(cdm_proxy_factory_cb)) {
 }
 
@@ -157,7 +157,7 @@ GpuMojoMediaClient::GetSupportedVideoDecoderConfigs() {
   supported_config_map[VideoDecoderImplementation::kAlternate] =
       *d3d11_supported_configs_;
 
-#elif BUILDFLAG(USE_CHROMEOS_MEDIA_ACCELERATION)
+#elif defined(USE_CHROMEOS_MEDIA_ACCELERATION)
   if (base::FeatureList::IsEnabled(kChromeosVideoDecoder)) {
     if (!cros_supported_configs_) {
       cros_supported_configs_ =
@@ -236,9 +236,8 @@ std::unique_ptr<VideoDecoder> GpuMojoMediaClient::CreateVideoDecoder(
               MaybeRenderEarlyManager::Create(gpu_task_runner_),
               std::move(ycbcr_helper)));
 
-#elif defined(OS_CHROMEOS)
+#elif defined(USE_CHROMEOS_MEDIA_ACCELERATION)
       if (base::FeatureList::IsEnabled(kChromeosVideoDecoder)) {
-#if BUILDFLAG(USE_CHROMEOS_MEDIA_ACCELERATION)
         auto frame_pool = std::make_unique<PlatformVideoFramePool>(
             gpu_memory_buffer_factory_);
         auto frame_converter = MailboxVideoFrameConverter::Create(
@@ -252,7 +251,6 @@ std::unique_ptr<VideoDecoder> GpuMojoMediaClient::CreateVideoDecoder(
         video_decoder = ChromeosVideoDecoderFactory::Create(
             task_runner, std::move(frame_pool), std::move(frame_converter),
             gpu_memory_buffer_factory_);
-#endif  // BUILDFLAG(USE_CHROMEOS_MEDIA_ACCELERATION)
       } else {
         video_decoder = VdaVideoDecoder::Create(
             task_runner, gpu_task_runner_, media_log->Clone(),
-- 
2.25.2

